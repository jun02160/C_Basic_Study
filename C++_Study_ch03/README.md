## 구조체 VS 클래스

구조체는 데이터형에 상관없이 연관 있는 데이터를 묶을 수 있는 문법적 장치이다. 연관 있는 데이터를 하나로 묶는다는 건 프로그램의 구현 및 관리에 매우 용이하다. 구조체 안에는 변수(관련 데이터)와 동작(함수)을 정의할 수 있다. 또한, 일관된 특정 데이터를 사용한다면 이를 enum으로 선언해서 관리할 수도 있다. 

이와 비슷한 기능을 하는 클래스를 정의하려면 struct → class 키워드로 바꾸면 된다. 즉, **C++의 구조체는 클래스의 일종이다.** 

### 접근제어 지시자

차이점은 클래스에는 내부에 정의한 멤버들의 접근을 제어할 수 있다는 점이다. 

- public : 어디서든 접근 허용
- protected : 상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용
- private : 클래스 내에서(클래스 내에 정의된 함수)만 접근 허용

## 클래스의 특징

- 접근제어 지시자가 선언되면, 그 이후에 등장하는 변수나 함수는 해당 범위 내에서 접근이 가능하다.
- 함수의 정의를 클래스 밖으로 빼도, 이는 클래스의 일부이기 때문에 함수 내에서는 private으로 선언된 변수에 접근이 가능하다.
- 키워드 struct를 이용해서 정의된 구조체(클래스)에 선언된 변수와 함수의 default 선언은 public이다.
- 키워드 class를 이용해서 정의된 클래스에 선언된 변수와 함수의 default 선언을 private이다.

## C++의 파일분할

.h 헤더파일 → 클래스의 선언 + inline 함수

.c/.cpp → 함수 및 클래스(멤버함수)의 정의

---

# 객체지향 프로그램의 특징

## 1️⃣ 정보은닉 (Information Hiding)

제한된 방법으로의 접근만 허용하여 잘못된 값이 저장되지 않도록 돕고, 실수를 했을 때 쉽게 발견될 수 있도록 대비해야 한다. 이는 클래스의 멤버변수를 private으로 선언하고, 해당 변수에 접근하는 함수(getter, setter 등)를 별도로 정의해서 안전한 형태로 멤버변수의 접근을 유도하는 방식이다. 이는 좋은 클래스가 되기 위한 기본 조건이 된다. 

*const 함수의 특징 - const 함수 내에서는 const가 아닌 함수의 호출이 제한된다!

## 2️⃣ 캡슐화 (Encapsulation)

캡슐화는 말그대로 감싸는 개념이므로, 정보은닉의 개념을 기본적으로 내포한다. 
### 생성자(Constructor)

> 생성자의 Polymorphism : 클래스에서는 파라미터의 개수와 타입이 다른 복수 개의 생성자를 정의할 수 있다.
> 

파라미터가 하나도 없는 생성자를 **Default Constructor(디폴트 생성자)**라고 한다. (생성자에 대한 정의를 따로 해주지 않아도 자동으로 함수가 텅 빈 블록으로 정의되고 호출되는 것이다.)

→ 디폴트 생성자는 사용자가 정의한 생성자가 하나도 없다는 전제 하에 생성된다. 즉, 하나라도 정의된 생성자가 있는 경우에는 디폴트 생성자가 생성되지 않는다. 

**Copy Constructor** : 생성자 중 파라미터를 나 자신으로 가지는 Special constructor

### 소멸자(Destructor)

클래스명과 이름이 같은 멤버함수인 생성자의 형태에 ~가 붙은 이름으로 사용되며, 클래스가 메모리에서 소멸할 때 자동호출되는 메서드이다. 

⇒ 사용자의 명시적인 호출 불가 (메모리에서 인스턴스가 소멸될 때 자동적으로 호출되는 방식)

- 파라미터 無 ← 명시적인 호출이 아니므로 파라미터를 따로 지정할 수 없음
- 오직 하나만 정의 가능  ex. `~Sample()`
- 메모리 누수 현상을 방지하기 위해서 동적 생성한 포인터 변수, 배열 등에 대하여 delete를 명시하는 코드를 소멸자에 적어준다.

## 3️⃣ 생성자 (Constructor)와 소멸자 (Destructor)
### 생성자(Constructor)

> 생성자의 Polymorphism : 클래스에서는 파라미터의 개수와 타입이 다른 복수 개의 생성자를 정의할 수 있다.
> 

파라미터가 하나도 없는 생성자를 **Default Constructor(디폴트 생성자)**라고 한다. (생성자에 대한 정의를 따로 해주지 않아도 자동으로 함수가 텅 빈 블록으로 정의되고 호출되는 것이다.)

→ 디폴트 생성자는 사용자가 정의한 생성자가 하나도 없다는 전제 하에 생성된다. 즉, 하나라도 정의된 생성자가 있는 경우에는 디폴트 생성자가 생성되지 않는다. 

**Copy Constructor** : 생성자 중 파라미터를 나 자신으로 가지는 Special constructor

### 소멸자(Destructor)

클래스명과 이름이 같은 멤버함수인 생성자의 형태에 ~가 붙은 이름으로 사용되며, 클래스가 메모리에서 소멸할 때 자동호출되는 메서드이다. 

⇒ 사용자의 명시적인 호출 불가 (메모리에서 인스턴스가 소멸될 때 자동적으로 호출되는 방식)

- 파라미터 無 ← 명시적인 호출이 아니므로 파라미터를 따로 지정할 수 없음
- 오직 하나만 정의 가능  ex. `~Sample()`
- 메모리 누수 현상을 방지하기 위해서 동적 생성한 포인터 변수, 배열 등에 대하여 delete를 명시하는 코드를 소멸자에 적어준다.

<aside>
📓 **클래스의 Good Interface**

1. Minimal : 필요한 최소한만을 public 으로 두는 것이 좋다.
    - 어떤 멤버 변수 정의?
    - 목적을 위한 어떤 멤버 함수 정의?
    
    **⇒ private, public으로 멤버들을 나누는 캡슐화**
    
    1. 원칙적으로 모든 멤버 변수는 private으로 선언한다. 
    2. 필요에 따라 상속을 염두에 둔다면 protected로 선언한다. 
    3. public으로 선언한 멤버 함수에 대해 내부적으로는 매개변수와 리턴형에 대한 정보만을 명시하고 구현은 외부에서 한다. 
    4. public의 멤버함수에서 원하는 값을 얻기 위한 기능을 private으로 선언하는 것이 좋다.
2. Complete : 미래의 확장가능성을 염두에 두고 설계해야 한다.
3. Type safe (타입 안전성)
4. Const correct : const를 올바르게 지정해줘야 한다. 
</aside>

<aside>
🌀 Member Function에 대한 Declaration만 클래스 내부에 남겨두고, 정의는 클래스 밖으로 빼서 하는 것이 ******************권장사항******************이다.

</aside>
