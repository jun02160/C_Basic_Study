# 연산자 오버로딩의 이해

함수 오버로딩 시, 함수에 더욱 다양한 기능이 추가되는 것처럼 연산자의 오버로딩을 통해서 기존의 연산자 기능에 다른 기능을 추가할 수 있다. 

### HOW?

‘operator’ 키워드와 ‘연산자’를 묶어서 함수 이름을 정의하면, 함수의 이름을 이용한 함수의 호출뿐만 아니라 연산자를 이용한 함수의 호출도 허용해준다!

**pos1** **+** **pos2**  ⇒ **pos1.operator+(pos2)**

멤버함수를 이용해서 + 연산자를 오버로딩할 때, 컴파일러는 위와 같이 번역한다.

## 연산자를 오버로딩 하는 방법

1. 멤버함수에 의한 연산자 오버로딩
2. 전역함수에 의한 연산자 오버로딩

→ 두 개가 동시에 쓰인 경우, 멤버함수 기반으로 오버로딩 된 함수가 우선순위를 가진다. 

### 오버로딩이 불가능한 연산자의 종류

| . | 멤버 접근 연산자 |
| --- | --- |
| .* | 멤버 포인터 연산자 |
| :: | 범위 지정 연산자 |
| ?: | 조건 연산자(3항 연산자) |
| sizeof | 바이트 단위 크기 계산 |
| typeid | RTTI 관련 연산자 |
| static_cast | 형변환 연산자 |
| dynamic_cast | 형변환 연산자 |
| const_cast | 형변환 연산자 |
| reinterpret_cast | 형변환 연산자 |

### 멤버함수 기반으로만 오버로딩이 가능한 연산자 종류

→ 객체를 대상으로 진행해야 의미가 있는 연산자

| = | 대입 연산자 |
| --- | --- |
| ( ) | 함수 호출 연산자 |
| [ ] | 배열 접근 연산자(인덱스 연산자) |
| → | 멤버 접근을 위한 포인터 연산자 |

## 연산자 오버로딩 시 주의사항

- 본래의 의도를 벗어난 형태의 연산자 오버로딩은 좋지 않다.
- 연산자의 우선순위와 결합성은 바뀌지 않는다.
- 매개변수의 디폴트 값 설정이 불가능하다.
- 연산자의 순수 기능까지 빼앗을 수는 없다. (연산자의 기본 기능을 변경하는 형태의 연산자 오버로딩은 허용되지 않는다.)

함수가 오버로딩 되면 전달되는 인자에 따라서 호출되는 함수가 달라지듯이, 연산자가 오버로딩 되면 피연산자의 종류에 따라서 연산의 방식이 달라진다. 

# 단항 연산자의 오버로딩

<aside>
💡 피연산자의 개수에 따라 붙는 단항, 이항, 삼항 연산자를 오버로딩할 때의 차이점은 **매개변수 개수**에 있다.

</aside>

`++pos;` 에서의 증가 연산자 ‘++’ 가 오버로딩된 형태는 아래 두 가지 경우로 나눌 수 있다.

- 멤버함수로 오버로딩 된 경우 - `pos.operator++();` 피연산자의 멤버함수를 호출하는 형태
- 전역함수로 오버로딩 된 경우 - `operator++(pos);` operator++ 자체가 전역함수의 이름이 된다.

후위증가, 후위감소를 오버로딩 할 때는 int형을 매개변수로 추가하여 전위증가, 전위감소와 차이를 주어야 한다. 

*참고

const 함수 내에서는 const 함수의 호출만 허용하도록 제한하며, const 객체를 대상으로 참조자를 선언할 때에는 참조자도 const로 선언해야 한다. 이는 const 객체를 대상으로는 값의 변경능력을 지니는 const로 선언되지 않은 함수의 호출을 허용하지 않기 때문이다. 

# 교환법칙 문제의 해결

연산자 오버로딩을 통해서 연산에 사용되는 두 피연산자의 자료형이 일치하지 않아도 데이터 간의 연산을 지원한다. 그 중간 과정에서는 형 변환의 규칙에 따라서 자료형의 변환이 이루어진 다음 연산이 이루어져야 한다. 

멤버함수의 형태로 오버로딩 되면, 멤버함수가 정의된 클래스의 객체가 오버로딩 된 연산자의 왼편에 와야 하므로, 교환법칙이 성립하도록 이를 확장해보면 **전역함수의 형태로 오버로딩** 하여 참조자를 이용하는 방법으로도 구현해야 한다. 

# cout, cin, endl

C++의 콘솔 입출력에 사용되는 cout과 endl은 타입에 따라 오버로딩된 원형이 존재하며, 해당 객체에서는 다양한 기본 자료형 데이터를 대상으로 << 연산자를 오버로딩하고 있다. 

- 함수의 매개변수형을 인자로 받는 경우
    
    ```cpp
    void operator<< (ostream& (*fp) (ostream &ostm)) { fp(*this)); }
    ```
    
- primitive type을 인자로 받는 경우
    
    ```cpp
    void operator<< (char* str) { printf("%s", str); }   // String 
    void operator<< (int num) { printf("%d", num); }  // int
    void oprator<< (double e) { printf("%g", e); }   // double
    ```
    

### ostream

cout은 ostream 클래스의 객체이며, ostream은 이름공간 std 안에 선언되어 있다. 

→ 이를 사용하려면 헤더파일 <iostream> 을 포함해야 한다. 

콘솔 출력 연산자인 `**<<**` 을 오버로딩하려면 리턴형과 매개변수 타입을 ostream& 으로 지정해야 한다. 

### istream

cin은 istream 클래스의 객체이며, istream은 이름공간 std 안에 선언되어 있다.

→ 이를 사용하려면 헤더파일 <iostream> 을 포함해야 한다. 

콘솔 입력 연산자인 `**>>`** 을 오버로딩하려면 리턴형과 매개변수 타입을 istream& 으로 지정해야 한다. 

# 대입 연산자의 오버로딩

> 복사 생성자의 성격과 매우 유사!
> 

### 복사 생성자 복습

- 정의하지 않으면 디폴트 복사 생성자가 삽입된다.  ➡️ ******************************************************************************정의하지 않으면 디폴트 대입 연산자가 삽입된다.******************************************************************************
- 디폴트 복사 생성자는 멤버 대 멤버의 얕은 복사를 진행한다.
- 생성자 내에서 동적 할당을 한다면, 또한 깊은 복사가 필요하다면 직접 정의해야 한다.

### 디폴트 대입 연산자의 형태

```cpp
Second& operator=(const Second& ref) {
    cout << "Second& operator=()" << endl;
    num3 = ref.num3;
    num4 = ref.num4;
    return *this;
}
```

디폴트 생성자와 같이 클래스마다 기본적으로 가지는 대입 연산자이다. 

즉, **동일한 자료형의 두 객체 간에 대입연산**을 기본적으로 제공한다. 

- `fcpy = fsrc`;   → `fcpy.operator = (fsrc)` 로 해석됨

디폴트 대입 연산자는 멤버 대 멤버를 단순 복사하므로, 하나의 문자열을 두 개의 객체가 동시 참조하는 상황이 벌어지게 된다. 따라서 발생하는 문제점은 자신을 가리키는 주소값의 변수가 사라지게 될 수 있다는 메모리 누수(leak) 상황과, 객체 소멸과정에서 지워진 문자열을 중복 소멸하는 문제가 발생한다. 

<aside>
🤍 **이를 방지하기 위해 우리는 대입 연산자를 깊은 복사의 형태로 직접 정의해야 하며, 메모리 누수가 발생하지 않도록 깊은 복사에 앞서 메모리 해제의 과정을 거쳐야 한다.**

</aside>

### 상속 구조에서의 대입 연산자 호출

유도(자식) 클래스의 대입 연산자 정의에서 명시적으로 기초(부모) 클래스의 대입 연산자 호출문을 삽입하지 않으면, 기초 클래스의 대입 연산자는 호출되지 않아서, 기초 클래스의 멤버변수는 멤버 대 멤버 복사 대상에서 제외된다. 

ex. `First::operator=(ref);`

*참고 - *“ C++에서, AAA형 참조자는 AAA 객체 또는 AAA를 직접 or 간접적으로 상속하는 모든 객체를 참조할 수 있다.”*
